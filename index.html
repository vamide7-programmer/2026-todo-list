<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="description" content="2026 Planning Dashboard with weekly tracking">
    <meta name="theme-color" content="#1a4d2e">
    <link rel="manifest" href="data:application/json;base64,ewogICJuYW1lIjogIjIwMjYgVG8tRG8gTGlzdCIsCiAgInNob3J0X25hbWUiOiAiMjAyNiBQbGFucyIsCiAgInN0YXJ0X3VybCI6ICIuLyIsCiAgImRpc3BsYXkiOiAic3RhbmRhbG9uZSIsCiAgImJhY2tncm91bmRfY29sb3IiOiAiIzFhNGQyZSIsCiAgInRoZW1lX2NvbG9yIjogIiMxYTRkMmUiLAogICJpY29ucyI6IFsKICAgIHsKICAgICAgInNyYyI6ICJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zycgd2lkdGg9JzE5MicgaGVpZ2h0PScxOTInJTNFJTNDcmVjdCB3aWR0aD0nMTkyJyBoZWlnaHQ9JzE5MicgZmlsbD0nJTIzMWE0ZDJlJy8lM0UlM0N0ZXh0IHg9Jzk2JyB5PSc5NicgZm9udC1zaXplPSc4MCcgdGV4dC1hbmNob3I9J21pZGRsZScgZHk9Jy4zZW0nIGZpbGw9J3doaXRlJyUzRTI2JTNDL3RleHQlM0UlM0Mvc3ZnJTNFIiwKICAgICAgInNpemVzIjogIjE5MngxOTIiLAogICAgICAidHlwZSI6ICJpbWFnZS9zdmcreG1sIgogICAgfSwKICAgIHsKICAgICAgInNyYyI6ICJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zycgd2lkdGg9JzUxMicgaGVpZ2h0PSc1MTInJTNFJTNDcmVjdCB3aWR0aD0nNTEyJyBoZWlnaHQ9JzUxMicgZmlsbD0nJTIzMWE0ZDJlJy8lM0UlM0N0ZXh0IHg9JzI1NicgeT0nMjU2JyBmb250LXNpemU9JzIwMCcgdGV4dC1hbmNob3I9J21pZGRsZScgZHk9Jy4zZW0nIGZpbGw9J3doaXRlJyUzRTI2JTNDL3RleHQlM0UlM0Mvc3ZnJTNFIiwKICAgICAgInNpemVzIjogIjUxMng1MTIiLAogICAgICAidHlwZSI6ICJpbWFnZS9zdmcreG1sIgogICAgfQogIF0KfQ==">
    <title>2026 To-Do List</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a4d2e;
            color: #333;
            padding: 20px 20px 40px 20px;
            overflow-x: auto;
            min-height: 100vh;
            height: auto;
            margin: 0;
        }
        
        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }
        
        .header h1 {
            font-size: 2.8em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            font-family: 'Brush Script MT', 'Lucida Handwriting', cursive;
            font-weight: bold;
        }
        
        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .controls {
            background: #f4e8d0;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        
        .button-stack {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .button-stack button {
            width: 100%;
        }
        
        .controls button {
            padding: 10px 20px;
            background: #2d6a4f;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95em;
            transition: background 0.3s ease;
            white-space: nowrap;
        }
        
        .controls button:hover {
            background: #1b4332;
        }
        
        .timeline-container {
            background: #f4e8d0;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            overflow-x: auto;
            position: relative;
            transition: all 0.3s ease;
            margin-bottom: 20px;
        }
        
        .timeline-container.zoomed-out {
            padding: 5px;
            font-size: 0.5em;
        }
        
        .timeline-container.zoomed-out .week-label {
            min-height: 30px;
            padding: 4px;
            font-size: 0.7em;
        }
        
        .timeline-container.zoomed-out .task-item {
            padding: 3px;
            font-size: 0.6em;
            min-height: 20px;
        }
        
        .timeline-container.zoomed-out .plan-header {
            padding: 8px;
            font-size: 0.8em;
        }
        
        .timeline-grid {
            display: grid;
            gap: 0;
            min-width: 100%;
            position: relative;
        }
        
        .week-row-wrapper {
            display: contents;
        }
        
        .week-column {
            background: #ebe0ca;
            padding: 15px 10px;
            border-radius: 8px;
            position: relative;
        }
        
        .week-label {
            font-weight: bold;
            color: #1a4d2e;
            font-size: 0.9em;
            padding: 12px 8px;
            background: #f4e8d0;
            border-radius: 5px;
            margin-bottom: 0;
            text-align: center;
            border-left: 4px solid #2d6a4f;
            min-height: 80px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        .full-width-divider {
            grid-column: 1 / -1;
            height: 1px;
            background: #999;
            margin: 0;
            width: 100%;
        }
        
        .full-width-divider.month-end {
            height: 1px;
            background: #999;
        }
        
        .month-reflection {
            grid-column: 1 / -1;
            text-align: center;
            padding: 30px 20px;
            background: transparent;
            margin: 20px 0;
        }
        
        .month-reflection-btn {
            padding: 12px 40px;
            background: #2d6a4f;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1.1em;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        
        .month-reflection-btn:hover {
            background: #1b4332;
            transform: scale(1.05);
        }
        
        .month-reflection-box {
            display: none;
            margin-top: 20px;
            padding: 30px;
            background: #fffbf0;
            border: 3px solid #2d6a4f;
            border-radius: 12px;
            width: 95%;
            margin-left: auto;
            margin-right: auto;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .month-reflection-box.active {
            display: block;
        }
        
        .month-reflection-box textarea {
            width: 100%;
            min-height: 150px;
            padding: 20px;
            border: 2px solid #d4c5a9;
            border-radius: 8px;
            font-family: 'Georgia', serif;
            font-size: 1.05em;
            line-height: 1.6;
            resize: vertical;
            background: #f4e8d0;
        }
        
        .reflection-label {
            font-weight: bold;
            color: #1a4d2e;
            margin-bottom: 15px;
            font-size: 1.3em;
            font-family: 'Brush Script MT', 'Lucida Handwriting', cursive;
        }
        
        .plan-column {
            background: #f4e8d0;
            border: 2px solid #d4c5a9;
            border-radius: 10px;
            padding: 15px;
            min-height: 200px;
            position: relative;
        }
        
        .plan-header {
            background: #2d6a4f;
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-weight: bold;
            font-size: 1.1em;
            text-align: center;
            cursor: pointer;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .plan-header:hover {
            background: #1b4332;
        }
        
        /* RAINBOW ARCH FOR HABITS */
        .habits-column {
            background: #f9f3e8;
            padding: 15px 10px;
            border-radius: 10px;
            position: relative;
            min-height: 180px;
            cursor: pointer;
        }
        
        .habits-column:hover {
            background: #f5eed8;
        }
        
        @keyframes sparkle {
            0%, 100% { 
                opacity: 1;
                transform: translateX(-50%) scale(1);
                filter: drop-shadow(0 0 10px gold);
            }
            50% { 
                opacity: 0.7;
                transform: translateX(-50%) scale(1.2);
                filter: drop-shadow(0 0 20px gold) brightness(1.5);
            }
        }
        
        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            background: gold;
            animation: fall 3s linear;
            z-index: 9999;
        }
        
        @keyframes fall {
            to {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }
        
        .tasks-container {
            position: relative;
        }
        
        .task-item {
            background: #f4e8d0;
            padding: 12px;
            margin: 8px 0;
            border-radius: 8px;
            border: 2px solid #d4c5a9;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .task-item:hover {
            border-color: #2d6a4f;
            transform: translateX(5px);
            box-shadow: 0 3px 6px rgba(0,0,0,0.15);
        }
        
        .task-actions {
            display: none;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #d4c5a9;
            gap: 8px;
        }
        
        .task-item.show-actions .task-actions {
            display: flex;
        }
        
        .task-action-btn {
            padding: 4px 10px;
            background: #e8dcc4;
            border: 1px solid #d4c5a9;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.2s ease;
        }
        
        .task-action-btn:hover {
            background: #d4c5a9;
        }
        
        .task-action-btn.complete {
            background: #b8ddc8;
            border-color: #52b788;
        }
        
        .task-action-btn.complete:hover {
            background: #a0d4b4;
        }
        
        .task-action-btn.delete {
            background: #f8d7da;
            border-color: #dc3545;
        }
        
        .task-action-btn.delete:hover {
            background: #f1b6bc;
        }
        
        .plan-context-menu {
            display: none;
            position: fixed;
            background: white;
            border: 2px solid #2d6a4f;
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            z-index: 1000;
        }
        
        .plan-context-menu.active {
            display: block;
        }
        
        .plan-context-menu button {
            display: block;
            width: 100%;
            padding: 10px 15px;
            margin: 5px 0;
            background: #f4e8d0;
            border: 1px solid #d4c5a9;
            border-radius: 5px;
            cursor: pointer;
            text-align: left;
            font-size: 0.95em;
            transition: all 0.2s ease;
        }
        
        .plan-context-menu button:hover {
            background: #e8dcc4;
            transform: translateX(3px);
        }
        
        .plan-context-menu button.delete-plan {
            background: #f8d7da;
            border-color: #dc3545;
        }
        
        .plan-context-menu button.delete-plan:hover {
            background: #f1b6bc;
        }
        
        .task-item.completed {
            background: #d4edda;
            border-color: #52b788;
        }
        
        .task-item.completed .task-text {
            text-decoration: line-through;
        }
        
        .task-item.overdue {
            background: #f8d7da;
            border-color: #dc3545;
        }
        
        .task-week {
            font-size: 0.75em;
            color: #666;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .task-text {
            font-size: 0.9em;
            line-height: 1.4;
        }
        
        .task-status {
            display: inline-block;
            margin-right: 8px;
            font-size: 1.2em;
        }
        
        .add-task-btn {
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            background: #95d5b2;
            color: #1a4d2e;
            border: 2px dashed #2d6a4f;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .add-task-btn:hover {
            background: #74c69d;
            border-style: solid;
        }
        
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
        }
        
        .modal-content {
            background: #f4e8d0;
            margin: 5% auto;
            padding: 30px;
            border-radius: 15px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }
        
        .modal-content h2 {
            color: #1a4d2e;
            margin-bottom: 20px;
        }
        
        .modal-content label {
            display: block;
            margin: 15px 0 5px;
            color: #333;
            font-weight: bold;
        }
        
        .modal-content input,
        .modal-content select,
        .modal-content textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0ddd4;
            border-radius: 8px;
            font-size: 1em;
            font-family: inherit;
            background: white;
        }
        
        .modal-content textarea {
            resize: vertical;
            min-height: 80px;
        }
        
        .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        .modal-buttons button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            font-weight: bold;
        }
        
        .btn-save {
            background: #2d6a4f;
            color: white;
        }
        
        .btn-save:hover {
            background: #1b4332;
        }
        
        .btn-cancel {
            background: #e0e0e0;
            color: #333;
        }
        
        .btn-cancel:hover {
            background: #d0d0d0;
        }
        
        .countdown-timers {
            display: flex;
            justify-content: center;
            gap: 30px;
            padding: 20px;
            background: rgba(244, 232, 208, 0.9);
            border-radius: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        
        .timer-circle {
            position: relative;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .timer-circle:hover {
            transform: scale(1.05);
        }
        
        .timer-circle canvas {
            display: block;
        }
        
        .timer-star {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 40px;
            animation: sparkle 1s infinite;
        }
        
        @keyframes sparkle {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
        }
        
        .timer-label {
            text-align: center;
            font-size: 0.75em;
            margin-top: 5px;
            color: #1a4d2e;
            font-weight: 600;
            max-width: 80px;
            word-wrap: break-word;
        }
        
        .floating-add-btn {
            position: fixed !important;
            bottom: 30px !important;
            right: 30px !important;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: #2d6a4f;
            color: white;
            border: none;
            font-size: 2em;
            cursor: pointer;
            box-shadow: 0 6px 20px rgba(0,0,0,0.4);
            transition: all 0.3s ease;
            z-index: 999999 !important;
            display: flex;
            align-items: center;
            will-change: transform;
            justify-content: center;
        }
        
        .floating-add-btn:hover {
            background: #1b4332;
            transform: scale(1.1);
            box-shadow: 0 8px 25px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>2026 To-Do List üéØ</h1>
        <p>Planning paradise: Every week mapped to perfection</p>
    </div>
    
    <div class="countdown-timers">
        <h2 style="color: #1a4d2e; margin: 0 0 15px 0; font-size: 2em; width: 100%; text-align: center; font-weight: bold; font-family: 'Brush Script MT', 'Lucida Handwriting', cursive;">Milestones Timer</h2>
        <div class="timer-circle" id="timer1" onclick="editTimer(0)">
            <canvas id="canvas0" width="80" height="80"></canvas>
            <div class="timer-star" id="star0">‚≠ê</div>
            <div class="timer-label" id="label0">Set Timer 1</div>
        </div>
        <div class="timer-circle" id="timer2" onclick="editTimer(1)">
            <canvas id="canvas1" width="80" height="80"></canvas>
            <div class="timer-star" id="star1">‚≠ê</div>
            <div class="timer-label" id="label1">Set Timer 2</div>
        </div>
        <div class="timer-circle" id="timer3" onclick="editTimer(2)">
            <canvas id="canvas2" width="80" height="80"></canvas>
            <div class="timer-star" id="star2">‚≠ê</div>
            <div class="timer-label" id="label2">Set Timer 3</div>
        </div>
        <div class="timer-circle" id="timer4" onclick="editTimer(3)">
            <canvas id="canvas3" width="80" height="80"></canvas>
            <div class="timer-star" id="star3">‚≠ê</div>
            <div class="timer-label" id="label3">Set Timer 4</div>
        </div>
        <div class="timer-circle" id="timer5" onclick="editTimer(4)">
            <canvas id="canvas4" width="80" height="80"></canvas>
            <div class="timer-star" id="star4">‚≠ê</div>
            <div class="timer-label" id="label4">Set Timer 5</div>
        </div>
    </div>
    
    <div class="controls">
        <div class="button-stack">
            <button id="jumpToWeekBtn">üìç Jump to Current Week</button>
            <button id="addColBtn">‚ûï Add Column</button>
        </div>
        <div class="button-stack">
            <button id="undoBtn">‚Ü©Ô∏è Undo</button>
            <button id="redoBtn">‚Ü™Ô∏è Redo</button>
        </div>
        <div class="button-stack">
            <button id="zoomOutBtn">üîç- Out</button>
            <button id="zoomInBtn">üîç+ In</button>
        </div>
    </div>
    
    <!-- Floating Add Task Button -->
    <button class="floating-add-btn" id="floatingAddBtn" title="Add Task">+</button>
    
    <div class="timeline-container">
        <div class="timeline-grid" id="timelineGrid">
            <!-- Grid will be generated -->
        </div>
    </div>
    
    <!-- Annual Achievement Tracker -->
    <div id="annualTracker" style="max-width: 1200px; margin: 40px auto 60px auto; padding: 30px; background: #f4e8d0; border-radius: 15px; box-shadow: 0 4px 10px rgba(0,0,0,0.3);">
        <h2 style="text-align: center; color: #1a4d2e; margin-bottom: 20px; font-family: 'Brush Script MT', 'Lucida Handwriting', cursive; font-size: 2em;">2026 Annual Achievement</h2>
        
        <div style="position: relative; height: 60px; background: #fff; border-radius: 30px; overflow: hidden; box-shadow: inset 0 2px 5px rgba(0,0,0,0.1); margin-bottom: 15px;">
            <div id="annualProgressBar" style="height: 100%; width: 0%; background: #e0e0e0; transition: width 0.5s ease, background 0.5s ease; border-radius: 30px;"></div>
            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 1.3em; font-weight: bold; color: #1a4d2e; text-shadow: 0 0 3px white;"><span id="annualProgress">0</span>/42 weeks (80%)</div>
        </div>
        
        <div style="text-align: center; margin: 20px 0;">
            <div id="annualTrophy" style="font-size: 4em; opacity: 0.2; transition: all 0.5s ease;">üèÜ</div>
        </div>
        
        <div style="margin-top: 20px;">
            <label style="display: block; font-weight: bold; margin-bottom: 10px; color: #1a4d2e;">What does your annual trophy represent?</label>
            <input type="text" id="trophyPrize" placeholder="E.g., Trip to Bali, New car, Career milestone..." style="width: 100%; padding: 15px; border: 2px solid #2d6a4f; border-radius: 10px; font-size: 1.1em; box-sizing: border-box;" onchange="saveTrophyPrize(this.value)">
        </div>
    </div>
    
    <!-- Modal for adding tasks -->
    <div id="taskModal" class="modal">
        <div class="modal-content">
            <h2>Add New Task</h2>
            <label>Plan Column:</label>
            <select id="modalPlan"></select>
            
            <label>Week:</label>
            <select id="modalWeek">
                <option value="">Select a week...</option>
            </select>
            
            <label>Task Description:</label>
            <textarea id="modalTask" placeholder="Describe what needs to be done..."></textarea>
            
            <label>Status:</label>
            <select id="modalStatus">
                <option value="pending">Pending</option>
                <option value="completed">Completed</option>
            </select>
            
            <div class="modal-buttons">
                <button class="btn-save" onclick="saveTask()">Save Task</button>
                <button class="btn-cancel" onclick="closeModal()">Cancel</button>
            </div>
        </div>
    </div>
    
    <!-- Plan Context Menu -->
    <div id="planContextMenu" class="plan-context-menu">
        <button onclick="event.stopPropagation(); window.renamePlan()">‚úèÔ∏è Rename Plan</button>
        <button onclick="event.stopPropagation(); window.movePlanLeft()">‚¨ÖÔ∏è Move Left</button>
        <button onclick="event.stopPropagation(); window.movePlanRight()">‚û°Ô∏è Move Right</button>
        <button class="delete-plan" onclick="event.stopPropagation(); window.deletePlan()">üóëÔ∏è Delete Plan Column</button>
    </div>
    
    <script>
        const plans = [
            { id: 'planA', name: 'Plan A: Mum\'s Visa', tasks: [] },
            { id: 'planB', name: 'Plan B: Sister\'s Relocation', tasks: [] },
            { id: 'planC', name: 'Plan C: Cornwall House', tasks: [] },
            { id: 'planD', name: 'Plan D: Birmingham Sale', tasks: [] },
            { id: 'planE', name: 'üë∂ Plan E: Baby EDD', tasks: [] },
            { id: 'planF', name: 'Plan F: Publishing Career', tasks: [] },
            { id: 'planG', name: 'Plan G', tasks: [] },
            { id: 'planH', name: 'Plan H', tasks: [] },
            { id: 'planI', name: 'Plan I', tasks: [] },
            { id: 'planJ', name: 'Plan J', tasks: [] }
        ];
        
        const reflections = {};
        let selectedPlanIndex = null;
        
        // Undo/Redo system
        const undoHistory = [];
        const redoHistory = [];
        const MAX_UNDO = 20;
        
        function saveState() {
            const state = {
                plans: JSON.parse(JSON.stringify(plans)),
                reflections: JSON.parse(JSON.stringify(reflections)),
                timers: JSON.parse(JSON.stringify(timers))
            };
            undoHistory.push(state);
            if (undoHistory.length > MAX_UNDO) {
                undoHistory.shift();
            }
            // Clear redo history when new action is performed
            redoHistory.length = 0;
        }
        
        function undo() {
            if (undoHistory.length === 0) {
                customAlert('Nothing to undo!');
                return;
            }
            
            // Save current state to redo history
            const currentState = {
                plans: JSON.parse(JSON.stringify(plans)),
                reflections: JSON.parse(JSON.stringify(reflections)),
                timers: JSON.parse(JSON.stringify(timers))
            };
            redoHistory.push(currentState);
            
            const previousState = undoHistory.pop();
            
            // Restore plans
            plans.length = 0;
            plans.push(...previousState.plans);
            
            // Restore reflections
            Object.keys(reflections).forEach(key => delete reflections[key]);
            Object.assign(reflections, previousState.reflections);
            
            // Restore timers
            timers.forEach((timer, i) => {
                Object.assign(timer, previousState.timers[i]);
            });
            
            saveToLocalStorage();
            renderDashboard();
            updateTimers();
        }
        
        function redo() {
            if (redoHistory.length === 0) {
                customAlert('Nothing to redo!');
                return;
            }
            
            // Save current state to undo history
            const currentState = {
                plans: JSON.parse(JSON.stringify(plans)),
                reflections: JSON.parse(JSON.stringify(reflections)),
                timers: JSON.parse(JSON.stringify(timers))
            };
            undoHistory.push(currentState);
            
            const nextState = redoHistory.pop();
            
            // Restore plans
            plans.length = 0;
            plans.push(...nextState.plans);
            
            // Restore reflections
            Object.keys(reflections).forEach(key => delete reflections[key]);
            Object.assign(reflections, nextState.reflections);
            
            // Restore timers
            timers.forEach((timer, i) => {
                Object.assign(timer, nextState.timers[i]);
            });
            
            saveToLocalStorage();
            renderDashboard();
            updateTimers();
        }
        
        // Countdown timers
        const timerColors = {
            blue: '#0047AB',      // Deep cobalt blue
            green: '#006400',     // Deep forest green
            red: '#8B0000',       // Deep dark red
            purple: '#4B0082',    // Deep indigo purple
            yellow: '#B8860B',    // Deep golden yellow
            pink: '#C71585',      // Deep magenta pink
            brown: '#654321'      // Deep chocolate brown
        };
        
        const timers = [
            { label: '', targetDate: null, color: 'blue', startDate: null },
            { label: '', targetDate: null, color: 'green', startDate: null },
            { label: '', targetDate: null, color: 'red', startDate: null },
            { label: '', targetDate: null, color: 'purple', startDate: null },
            { label: '', targetDate: null, color: 'yellow', startDate: null }
        ];
        
        // HABIT TRACKING - Rainbow tracks!
        const habitColors = {
            red: '#FF0000',
            orange: '#FF7F00',
            yellow: '#FFFF00',
            green: '#00FF00',
            blue: '#87CEEB',  // Baby blue (Sky Blue)
            indigo: '#4B0082',
            violet: '#9400D3'
        };
        
        // Max 5 habits
        let habits = [
            { emoji: '', name: '', color: 'red', frequency: 7, weeklyLogs: {} }
            // weeklyLogs format: { '1': [true, false, true, true, false, true, true] }
        ];
        
        // Annual achievement tracking
        let potsOfGold = []; // Array of week numbers that earned pots
        const ANNUAL_GOAL = 42; // 42 out of 52 weeks
        let trophyPrize = '';
        
        function updateAnnualTracker() {
            const progress = potsOfGold.length;
            const percentage = Math.min(100, (progress / ANNUAL_GOAL) * 100);
            
            const progressBar = document.getElementById('annualProgressBar');
            const progressText = document.getElementById('annualProgress');
            const trophy = document.getElementById('annualTrophy');
            
            if (progressBar) {
                progressBar.style.width = percentage + '%';
                
                // Progressive rainbow: each completed week adds next color
                // ROYGBIV = 7 colors, repeat every 7 weeks
                const rainbowColors = ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3'];
                const numColors = Math.min(progress, rainbowColors.length);
                
                if (numColors === 0) {
                    progressBar.style.background = '#e0e0e0';
                } else if (numColors === 1) {
                    progressBar.style.background = rainbowColors[0];
                } else {
                    // Build gradient with only completed colors
                    const colorsToShow = rainbowColors.slice(0, numColors);
                    progressBar.style.background = `linear-gradient(90deg, ${colorsToShow.join(', ')})`;
                }
            }
            
            if (progressText) progressText.textContent = progress;
            
            if (trophy) {
                if (progress >= ANNUAL_GOAL) {
                    trophy.style.opacity = '1';
                    trophy.style.animation = 'sparkle 2s infinite';
                    // Show trophy prize modal
                    if (trophyPrize && !sessionStorage.getItem('trophyShown2026')) {
                        showTrophyPrize();
                        sessionStorage.setItem('trophyShown2026', 'true');
                    }
                } else {
                    trophy.style.opacity = '0.2';
                    trophy.style.animation = 'none';
                }
            }
        }
        
        function saveTrophyPrize(prize) {
            trophyPrize = prize;
            saveToLocalStorage();
        }
        
        function showTrophyPrize() {
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); display: flex; align-items: center; justify-content: center; z-index: 10000; animation: fadeIn 0.5s;';
            modal.innerHTML = `
                <div style="text-align: center; color: white; padding: 40px;">
                    <div style="font-size: 8em; animation: sparkle 2s infinite;">üèÜ</div>
                    <h1 style="font-size: 3em; margin: 20px 0; font-family: 'Brush Script MT', 'Lucida Handwriting', cursive;">CONGRATULATIONS!</h1>
                    <h2 style="font-size: 2em; margin: 20px 0;">You've unlocked your 2026 trophy!</h2>
                    <div style="font-size: 1.8em; margin: 30px 0; padding: 20px; background: rgba(255,255,255,0.2); border-radius: 15px; max-width: 600px;">
                        ${trophyPrize || 'Your amazing achievement!'}
                    </div>
                    <button onclick="this.closest('div[style*=\"position: fixed\"]').remove()" style="padding: 15px 40px; background: gold; color: #1a4d2e; border: none; border-radius: 10px; font-size: 1.3em; cursor: pointer; font-weight: bold; margin-top: 20px;">CLAIM YOUR PRIZE! üéâ</button>
                </div>
            `;
            document.body.appendChild(modal);
            showConfetti();
        }
        
        // Generate weeks for 2026 with corrected 5th weeks
        function generateWeeks() {
            const weekData = [
                // January
                { month: 'Jan', week: '1st', start: 'Jan 4', end: 'Jan 10', isMonthEnd: false },
                { month: 'Jan', week: '2nd', start: 'Jan 11', end: 'Jan 17', isMonthEnd: false },
                { month: 'Jan', week: '3rd', start: 'Jan 18', end: 'Jan 24', isMonthEnd: false },
                { month: 'Jan', week: '4th', start: 'Jan 25', end: 'Jan 31', isMonthEnd: true },
                // February
                { month: 'Feb', week: '1st', start: 'Feb 1', end: 'Feb 7', isMonthEnd: false },
                { month: 'Feb', week: '2nd', start: 'Feb 8', end: 'Feb 14', isMonthEnd: false },
                { month: 'Feb', week: '3rd', start: 'Feb 15', end: 'Feb 21', isMonthEnd: false },
                { month: 'Feb', week: '4th', start: 'Feb 22', end: 'Feb 28', isMonthEnd: true },
                // March
                { month: 'Mar', week: '1st', start: 'Mar 1', end: 'Mar 7', isMonthEnd: false },
                { month: 'Mar', week: '2nd', start: 'Mar 8', end: 'Mar 14', isMonthEnd: false },
                { month: 'Mar', week: '3rd', start: 'Mar 15', end: 'Mar 21', isMonthEnd: false },
                { month: 'Mar', week: '4th', start: 'Mar 22', end: 'Mar 28', isMonthEnd: false },
                { month: 'Mar', week: '5th', start: 'Mar 29', end: 'Apr 4', isMonthEnd: true },
                // April (adjusted)
                { month: 'Apr', week: '1st', start: 'Apr 5', end: 'Apr 11', isMonthEnd: false },
                { month: 'Apr', week: '2nd', start: 'Apr 12', end: 'Apr 18', isMonthEnd: false },
                { month: 'Apr', week: '3rd', start: 'Apr 19', end: 'Apr 25', isMonthEnd: false },
                { month: 'Apr', week: '4th', start: 'Apr 26', end: 'May 2', isMonthEnd: true },
                // May (adjusted)
                { month: 'May', week: '1st', start: 'May 3', end: 'May 9', isMonthEnd: false },
                { month: 'May', week: '2nd', start: 'May 10', end: 'May 16', isMonthEnd: false },
                { month: 'May', week: '3rd', start: 'May 17', end: 'May 23', isMonthEnd: false },
                { month: 'May', week: '4th', start: 'May 24', end: 'May 30', isMonthEnd: true },
                // June (starts May 31)
                { month: 'Jun', week: '1st', start: 'May 31', end: 'Jun 6', isMonthEnd: false },
                { month: 'Jun', week: '2nd', start: 'Jun 7', end: 'Jun 13', isMonthEnd: false },
                { month: 'Jun', week: '3rd', start: 'Jun 14', end: 'Jun 20', isMonthEnd: false },
                { month: 'Jun', week: '4th', start: 'Jun 21', end: 'Jun 27', isMonthEnd: false },
                { month: 'Jun', week: '5th', start: 'Jun 28', end: 'Jul 4', isMonthEnd: true },
                // July (adjusted)
                { month: 'Jul', week: '1st', start: 'Jul 5', end: 'Jul 11', isMonthEnd: false },
                { month: 'Jul', week: '2nd', start: 'Jul 12', end: 'Jul 18', isMonthEnd: false },
                { month: 'Jul', week: '3rd', start: 'Jul 19', end: 'Jul 25', isMonthEnd: false },
                { month: 'Jul', week: '4th', start: 'Jul 26', end: 'Aug 1', isMonthEnd: true },
                // August (adjusted)
                { month: 'Aug', week: '1st', start: 'Aug 2', end: 'Aug 8', isMonthEnd: false },
                { month: 'Aug', week: '2nd', start: 'Aug 9', end: 'Aug 15', isMonthEnd: false },
                { month: 'Aug', week: '3rd', start: 'Aug 16', end: 'Aug 22', isMonthEnd: false },
                { month: 'Aug', week: '4th', start: 'Aug 23', end: 'Aug 29', isMonthEnd: true },
                // September (starts Aug 30)
                { month: 'Sep', week: '1st', start: 'Aug 30', end: 'Sep 5', isMonthEnd: false },
                { month: 'Sep', week: '2nd', start: 'Sep 6', end: 'Sep 12', isMonthEnd: false },
                { month: 'Sep', week: '3rd', start: 'Sep 13', end: 'Sep 19', isMonthEnd: false },
                { month: 'Sep', week: '4th', start: 'Sep 20', end: 'Sep 26', isMonthEnd: false },
                { month: 'Sep', week: '5th', start: 'Sep 27', end: 'Oct 3', isMonthEnd: true },
                // October (adjusted)
                { month: 'Oct', week: '1st', start: 'Oct 4', end: 'Oct 10', isMonthEnd: false },
                { month: 'Oct', week: '2nd', start: 'Oct 11', end: 'Oct 17', isMonthEnd: false },
                { month: 'Oct', week: '3rd', start: 'Oct 18', end: 'Oct 24', isMonthEnd: false },
                { month: 'Oct', week: '4th', start: 'Oct 25', end: 'Oct 31', isMonthEnd: true },
                // November (adjusted)
                { month: 'Nov', week: '1st', start: 'Nov 1', end: 'Nov 7', isMonthEnd: false },
                { month: 'Nov', week: '2nd', start: 'Nov 8', end: 'Nov 14', isMonthEnd: false },
                { month: 'Nov', week: '3rd', start: 'Nov 15', end: 'Nov 21', isMonthEnd: false },
                { month: 'Nov', week: '4th', start: 'Nov 22', end: 'Nov 28', isMonthEnd: true },
                // December (starts Nov 29)
                { month: 'Dec', week: '1st', start: 'Nov 29', end: 'Dec 5', isMonthEnd: false },
                { month: 'Dec', week: '2nd', start: 'Dec 6', end: 'Dec 12', isMonthEnd: false },
                { month: 'Dec', week: '3rd', start: 'Dec 13', end: 'Dec 19', isMonthEnd: false },
                { month: 'Dec', week: '4th', start: 'Dec 20', end: 'Dec 26', isMonthEnd: false },
                { month: 'Dec', week: '5th', start: 'Dec 27', end: 'Jan 2', isMonthEnd: true }
            ];
            
            return weekData.map((w, i) => ({
                label: `${w.month} ${w.week} week`,
                dates: `${w.start} - ${w.end}`,
                number: i + 1,
                isMonthEnd: w.isMonthEnd,
                month: w.month
            }));
        }
        
        const weeks = generateWeeks();
        
        function editTimer(index) {
            const timer = timers[index];
            
            // Ask for label
            const label = prompt('What are you counting down to?', timer.label || '');
            if (label === null) return;
            
            // Ask for date
            const dateStr = prompt('Enter target date (YYYY-MM-DD format, must be in 2026):', timer.targetDate || '2026-04-10');
            if (dateStr === null) return;
            
            // Validate date
            const targetDate = new Date(dateStr);
            if (isNaN(targetDate.getTime()) || targetDate.getFullYear() !== 2026) {
                customAlert('Please enter a valid date in 2026 (format: YYYY-MM-DD)');
                return;
            }
            
            // Ask for color
            const colorOptions = Object.keys(timerColors).join(', ');
            const color = prompt(`Choose a color (${colorOptions}):`, timer.color).toLowerCase();
            if (!timerColors[color]) {
                customAlert('Invalid color. Using default.');
                timer.color = 'blue';
            } else {
                timer.color = color;
            }
            
            // Save timer
            saveState();
            timer.label = label.trim();
            timer.targetDate = dateStr;
            timer.startDate = timer.startDate || new Date().toISOString().split('T')[0];
            
            saveToLocalStorage();
            updateTimers();
        }
        
        function updateTimers() {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            timers.forEach((timer, index) => {
                const canvas = document.getElementById(`canvas${index}`);
                const ctx = canvas.getContext('2d');
                const label = document.getElementById(`label${index}`);
                const star = document.getElementById(`star${index}`);
                
                // Clear canvas
                ctx.clearRect(0, 0, 80, 80);
                
                if (!timer.targetDate) {
                    // Not set up yet - show gray circle
                    ctx.beginPath();
                    ctx.arc(40, 40, 35, 0, 2 * Math.PI);
                    ctx.fillStyle = '#e0e0e0';
                    ctx.fill();
                    label.textContent = `Set Timer ${index + 1}`;
                    star.style.display = 'none';
                    canvas.style.display = 'block';
                    return;
                }
                
                const start = new Date(timer.startDate);
                const target = new Date(timer.targetDate);
                start.setHours(0, 0, 0, 0);
                target.setHours(0, 0, 0, 0);
                
                const totalDays = Math.ceil((target - start) / (1000 * 60 * 60 * 24));
                const daysRemaining = Math.ceil((target - today) / (1000 * 60 * 60 * 24));
                
                label.textContent = timer.label;
                
                if (daysRemaining <= 0) {
                    // Time's up! Show star
                    canvas.style.display = 'none';
                    star.style.display = 'block';
                } else {
                    // Draw the countdown circle
                    canvas.style.display = 'block';
                    star.style.display = 'none';
                    
                    // First draw gray background circle
                    ctx.beginPath();
                    ctx.arc(40, 40, 35, 0, 2 * Math.PI);
                    ctx.fillStyle = '#e0e0e0';
                    ctx.fill();
                    
                    // Calculate remaining percentage
                    const percentRemaining = daysRemaining / totalDays;
                    const endAngle = -Math.PI / 2 + (percentRemaining * 2 * Math.PI);
                    
                    // Draw colored arc (remaining time) - anticlockwise
                    ctx.beginPath();
                    ctx.moveTo(40, 40);
                    ctx.arc(40, 40, 35, -Math.PI / 2, endAngle, false);
                    ctx.closePath();
                    ctx.fillStyle = timerColors[timer.color];
                    ctx.fill();
                    
                    // Draw days remaining text in center
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(daysRemaining, 40, 40);
                }
            });
        }
        
        // HABIT TRACKING FUNCTIONS
        let habitSetupState = { step: 0, currentHabit: 0, totalHabits: 0, tempHabits: [] };
        
        function setupHabits() {
            // If habits already exist, show overview first
            if (habits.length > 0 && habits.some(h => h.emoji)) {
                showHabitsOverview();
            } else {
                habitSetupState = { step: 0, currentHabit: 0, totalHabits: 0, tempHabits: [] };
                showHabitSetupModal();
            }
        }
        
        function showHabitsOverview() {
            let html = `
                <div style="background: white; padding: 30px; border-radius: 15px; max-width: 450px;">
                    <h2 style="margin-top: 0; text-align: center;">Your Daily Habits</h2>
                    <div style="margin: 20px 0;">
                        ${habits.map((habit, idx) => {
                            if (!habit.emoji) return '';
                            return `
                                <div onclick="editHabit(${idx})" style="padding: 15px; margin: 10px 0; background: #f4e8d0; border-radius: 10px; cursor: pointer; display: flex; align-items: center; gap: 15px; border: 2px solid #ddd;">
                                    <div style="font-size: 2em;">${habit.emoji}</div>
                                    <div style="flex: 1;">
                                        <div style="font-weight: bold; font-size: 1.1em;">${habit.name}</div>
                                        <div style="color: #666; font-size: 0.9em;">${habit.frequency}x per week ‚Ä¢ <span style="color: ${habitColors[habit.color]};">‚óè</span> ${habit.color}</div>
                                    </div>
                                    <div style="color: #2d6a4f; font-weight: bold;">Edit ‚Üí</div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                    <div style="display: flex; gap: 10px; margin-top: 20px;">
                        <button onclick="startFreshHabitSetup()" style="flex: 1; padding: 12px; background: #2d6a4f; color: white; border: none; border-radius: 8px; cursor: pointer;">Start Over</button>
                        <button onclick="closeHabitSetup()" style="flex: 1; padding: 12px; background: #999; color: white; border: none; border-radius: 8px; cursor: pointer;">Done</button>
                    </div>
                </div>
            `;
            
            const modal = document.createElement('div');
            modal.id = 'habitSetupModal';
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 10000; padding: 20px; box-sizing: border-box;';
            modal.innerHTML = html;
            document.body.appendChild(modal);
        }
        
        function editHabit(habitIdx) {
            habitSetupState = {
                step: 1,
                currentHabit: habitIdx,
                totalHabits: habits.length,
                tempHabits: JSON.parse(JSON.stringify(habits))
            };
            closeHabitSetup();
            showHabitSetupModal();
        }
        
        function startFreshHabitSetup() {
            habitSetupState = { step: 0, currentHabit: 0, totalHabits: 0, tempHabits: [] };
            closeHabitSetup();
            showHabitSetupModal();
        }
        
        function selectColor(color) {
            const currentHabit = habitSetupState.tempHabits[habitSetupState.currentHabit];
            currentHabit.color = color;
            // Update all color boxes
            const colorOptions = Object.keys(habitColors);
            colorOptions.forEach(c => {
                const box = document.getElementById(`color-${c}`);
                if (box) {
                    box.style.border = c === color ? '3px solid #000' : '3px solid #ddd';
                }
            });
        }
        
        function selectFrequency(freq) {
            const currentHabit = habitSetupState.tempHabits[habitSetupState.currentHabit];
            currentHabit.frequency = freq;
            // Update all frequency boxes
            [7, 5, 3, 1].forEach(f => {
                const box = document.getElementById(`freq-${f}`);
                if (box) {
                    box.style.background = f === freq ? '#2d6a4f' : '#f0f0f0';
                    box.style.color = f === freq ? 'white' : '#333';
                    box.style.border = f === freq ? '2px solid #2d6a4f' : '2px solid #ddd';
                }
            });
        }
        
        function showHabitSetupModal() {
            const state = habitSetupState;
            let html = '';
            
            if (state.step === 0) {
                // Step 1: How many habits?
                html = `
                    <div style="background: white; padding: 30px; border-radius: 15px; max-width: 400px; text-align: center;">
                        <h2 style="margin-top: 0;">Setup Daily Habits</h2>
                        <p>How many habits do you want to track?</p>
                        <div style="display: flex; gap: 15px; justify-content: center; margin: 30px 0;">
                            ${[1,2,3,4,5].map(n => `<button onclick="selectHabitCount(${n})" style="width: 60px; height: 60px; font-size: 1.5em; background: #2d6a4f; color: white; border: none; border-radius: 10px; cursor: pointer;">${n}</button>`).join('')}
                        </div>
                        <button onclick="closeHabitSetup()" style="padding: 10px 30px; background: #999; color: white; border: none; border-radius: 8px; cursor: pointer;">Cancel</button>
                    </div>
                `;
            } else {
                // Step 2+: Configure each habit
                const habitNum = state.currentHabit + 1;
                const currentHabit = state.tempHabits[state.currentHabit] || { emoji: '', name: '', color: 'red', frequency: 7 };
                const colorOptions = Object.keys(habitColors);
                
                html = `
                    <div style="background: white; padding: 30px; border-radius: 15px; max-width: 450px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                            <button onclick="goBackHabitSetup()" style="padding: 8px 20px; background: #666; color: white; border: none; border-radius: 8px; cursor: pointer;">‚Üê Back</button>
                            <h3 style="margin: 0;">Habit ${habitNum} of ${state.totalHabits}</h3>
                            <div style="width: 80px;"></div>
                        </div>
                        
                        <div style="margin: 20px 0;">
                            <label style="display: block; margin-bottom: 8px; font-weight: bold;">Emoji:</label>
                            <input type="text" id="habitEmoji" value="${currentHabit.emoji}" placeholder="üßò üí™ üìñ ‚úçÔ∏è üé®" style="width: 100%; padding: 12px; font-size: 1.5em; border: 2px solid #ddd; border-radius: 8px; box-sizing: border-box;">
                        </div>
                        
                        <div style="margin: 20px 0;">
                            <label style="display: block; margin-bottom: 8px; font-weight: bold;">Name:</label>
                            <input type="text" id="habitName" value="${currentHabit.name}" placeholder="e.g., Yoga, Exercise, Reading" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; box-sizing: border-box;">
                        </div>
                        
                        <div style="margin: 20px 0;">
                            <label style="display: block; margin-bottom: 8px; font-weight: bold;">Frequency (days per week):</label>
                            <div id="frequencyPicker" style="display: flex; gap: 10px; flex-wrap: wrap;">
                                ${[7, 5, 3, 1].map(freq => `
                                    <div onclick="selectFrequency(${freq})" id="freq-${freq}" style="flex: 1; min-width: 100px; padding: 12px; background: ${currentHabit.frequency === freq ? '#2d6a4f' : '#f0f0f0'}; color: ${currentHabit.frequency === freq ? 'white' : '#333'}; border-radius: 8px; text-align: center; border: 2px solid ${currentHabit.frequency === freq ? '#2d6a4f' : '#ddd'}; cursor: pointer;">
                                        ${freq}x<br><small>${freq === 7 ? 'Daily' : freq === 5 ? 'Weekdays' : freq === 3 ? 'Alternate' : 'Weekly'}</small>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        
                        <div style="display: flex; gap: 10px; margin-top: 30px;">
                            <button onclick="saveCurrentHabit()" style="flex: 1; padding: 15px; background: #2d6a4f; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 1.1em;">${habitNum < state.totalHabits ? 'Next ‚Üí' : 'Finish ‚úì'}</button>
                        </div>
                    </div>
                `;
            }
            
            const modal = document.createElement('div');
            modal.id = 'habitSetupModal';
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 10000; padding: 20px; box-sizing: border-box;';
            modal.innerHTML = html;
            document.body.appendChild(modal);
        }
        
        function selectHabitCount(count) {
            habitSetupState.totalHabits = count;
            habitSetupState.step = 1;
            // Assign colors in BGYOR order automatically (Blue, Green, Yellow, Orange, Red)
            const colorOrder = ['blue', 'green', 'yellow', 'orange', 'red'];
            habitSetupState.tempHabits = Array(count).fill(null).map((_, idx) => ({ 
                emoji: '', 
                name: '', 
                color: colorOrder[idx] || 'blue', 
                frequency: 7 
            }));
            closeHabitSetup();
            showHabitSetupModal();
        }
        
        function goBackHabitSetup() {
            if (habitSetupState.currentHabit > 0) {
                habitSetupState.currentHabit--;
            } else {
                habitSetupState.step = 0;
            }
            closeHabitSetup();
            showHabitSetupModal();
        }
        
        function saveCurrentHabit() {
            const emoji = document.getElementById('habitEmoji').value.trim();
            const name = document.getElementById('habitName').value.trim();
            
            if (!emoji) {
                customAlert('Please enter an emoji!');
                return;
            }
            if (!name) {
                customAlert('Please enter a name!');
                return;
            }
            
            // Update the habit with text inputs (color and frequency already set via click handlers)
            habitSetupState.tempHabits[habitSetupState.currentHabit].emoji = emoji;
            habitSetupState.tempHabits[habitSetupState.currentHabit].name = name;
            // Preserve weeklyLogs if editing existing habit
            if (!habitSetupState.tempHabits[habitSetupState.currentHabit].weeklyLogs) {
                habitSetupState.tempHabits[habitSetupState.currentHabit].weeklyLogs = {};
            }
            
            if (habitSetupState.currentHabit < habitSetupState.totalHabits - 1) {
                habitSetupState.currentHabit++;
                closeHabitSetup();
                showHabitSetupModal();
            } else {
                // Finished all habits
                habits = habitSetupState.tempHabits;
                saveToLocalStorage();
                closeHabitSetup();
                renderDashboard();
            }
        }
        
        function closeHabitSetup() {
            const modal = document.getElementById('habitSetupModal');
            if (modal) modal.remove();
        }
        
        function renderRainbowTracks(weekNum) {
            if (!habits || habits.length === 0 || !habits.some(h => h.emoji)) {
                return ''; // Just show empty column
            }
            
            // Check if this week is in the future - FIX: Use actual week boundaries
            const today = new Date();
            const currentWeekData = weeks.find(w => {
                const [endMonth, endDay] = w.dates.split(' - ')[1].split(' ');
                const monthMap = {Jan:0, Feb:1, Mar:2, Apr:3, May:4, Jun:5, Jul:6, Aug:7, Sep:8, Oct:9, Nov:10, Dec:11};
                const endDate = new Date(2026, monthMap[endMonth], parseInt(endDay), 23, 59, 59);
                return today <= endDate;
            });
            const currentWeekIndex = currentWeekData ? currentWeekData.number : 52;
            const isFuture = weekNum > currentWeekIndex;
            
            // Calculate if all habits complete
            let allComplete = true;
            
            // FORCE BGYOR color order
            const colorOrder = ['blue', 'green', 'yellow', 'orange', 'red'];
            
            const habitData = habits.map((habit, idx) => {
                if (!habit.emoji) return null;
                
                const weekLogs = habit.weeklyLogs[weekNum] || Array(7).fill(false);
                const daysLogged = weekLogs.filter(Boolean).length;
                const progress = Math.min(100, (daysLogged / habit.frequency) * 100);
                const isComplete = daysLogged >= habit.frequency;
                
                // Debug logging
                console.log(`Week ${weekNum}, Habit ${idx}: ${daysLogged}/${habit.frequency} days = ${progress.toFixed(1)}%`, weekLogs);
                
                if (!isComplete) allComplete = false;
                
                const forcedColor = colorOrder[idx] || 'blue';
                
                return { habit, progress, isComplete, idx, color: forcedColor };
            }).filter(Boolean);
            
            const canvasId = `rainbow-canvas-${weekNum}`;
            const width = 260;
            const height = 120;
            const centerX = width / 2;
            const baseY = height - 5;
            
            // Generate HTML with canvas
            let html = `
                <div style="position: relative; width: 100%; height: ${height + 30}px; margin-top: 5px; ${isFuture ? 'opacity: 0.4; pointer-events: none;' : ''}">
                    <canvas id="${canvasId}" width="${width}" height="${height}" style="position: absolute; top: 0; left: 0; width: 100%;"></canvas>
            `;
            
            // Add emojis at the HEAD of each arc (where progress ends)
            if (!allComplete && !isFuture) {
                habitData.forEach((data, idx) => {
                    if (data.progress > 0) {
                        const radius = 95 - (idx * 17);
                        // End angle based on progress
                        const progressAngle = Math.PI - (data.progress / 100) * Math.PI;
                        const emojiX = centerX + radius * Math.cos(progressAngle);
                        const emojiY = baseY - radius * Math.sin(progressAngle);
                        
                        html += `<div style="position: absolute; left: ${emojiX}px; top: ${emojiY}px; transform: translate(-50%, -50%); font-size: 1.4em; filter: drop-shadow(0 2px 3px rgba(0,0,0,0.3)); z-index: 10;">${data.habit.emoji}</div>`;
                    }
                });
            }
            
            // Add sun behind cloud when complete - one per week, centered at the end
            if (allComplete) {
                const sunX = centerX + 100; // Position at the right end of the rainbow
                const sunY = baseY - 15;
                html += `<div style="position: absolute; left: ${sunX}px; top: ${sunY}px; transform: translateX(-50%); font-size: 2.5em; z-index: 10;">üå§</div>`;
            }
            
            html += `</div>`;
            
            // Draw arcs on canvas - ONLY UP TO PROGRESS!
            setTimeout(() => {
                const canvas = document.getElementById(canvasId);
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                
                // Clear canvas first to prevent multiple draws
                ctx.clearRect(0, 0, width, height);
                
                habitData.forEach((data, idx) => {
                    const radius = 95 - (idx * 17);
                    const color = habitColors[data.color];
                    
                    console.log(`Week ${weekNum}, Habit ${idx} (${data.color}): ${data.progress.toFixed(1)}% progress, daysLogged calculation in data object`);
                    
                    // Reset context state before each arc
                    ctx.save();
                    
                    // Gray base arc (FULL semicircle)
                    ctx.beginPath();
                    ctx.arc(centerX, baseY, radius, Math.PI, 0, false);
                    ctx.strokeStyle = '#d0d0d0';
                    ctx.lineWidth = 11;
                    ctx.lineCap = 'round';
                    ctx.globalAlpha = 0.25;
                    ctx.shadowBlur = 0;
                    ctx.stroke();
                    
                    ctx.restore();
                    ctx.save();
                    
                    // Colored progress arc - ONLY draw up to progress percentage!
                    if (data.progress > 0) {
                        // Draw CLOCKWISE from 180¬∞ (left) toward 0¬∞ (right)
                        // For 43%: go 43% of the semicircle = 180¬∞ + (43% √ó 180¬∞) = 257.4¬∞
                        const progressRadians = (Math.min(100, data.progress) / 100) * Math.PI;
                        const endAngle = Math.PI + progressRadians;
                        
                        console.log(`Progress ${data.progress}%: Drawing CLOCKWISE from ${(Math.PI * 180/Math.PI).toFixed(0)}¬∞ to ${(endAngle * 180/Math.PI).toFixed(1)}¬∞`);
                        
                        ctx.beginPath();
                        ctx.arc(centerX, baseY, radius, Math.PI, endAngle, false); // FALSE = CLOCKWISE!
                        ctx.strokeStyle = color;
                        ctx.lineWidth = 11;
                        ctx.lineCap = 'round';
                        ctx.globalAlpha = 0.95;
                        ctx.shadowColor = color;
                        ctx.shadowBlur = 8;
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                });
            }, 50);
            
            return html;
        }
        
        function openHabitLogger(weekNum) {
            if (!habits || !habits.some(h => h.emoji)) {
                customAlert('Please set up your habits first! Click "üåà Habits ‚ûï"');
                return;
            }
            
            // Block future weeks - FIX: Use actual week boundaries from the weeks array
            const today = new Date();
            const currentWeekData = weeks.find(w => {
                // Parse the week's end date
                const [endMonth, endDay] = w.dates.split(' - ')[1].split(' ');
                const monthMap = {Jan:0, Feb:1, Mar:2, Apr:3, May:4, Jun:5, Jul:6, Aug:7, Sep:8, Oct:9, Nov:10, Dec:11};
                const endDate = new Date(2026, monthMap[endMonth], parseInt(endDay), 23, 59, 59);
                return today <= endDate;
            });
            
            const currentWeekIndex = currentWeekData ? currentWeekData.number : 52;
            
            if (weekNum > currentWeekIndex) {
                customAlert('Cannot log habits for future weeks! Only current and past weeks can be logged.');
                return;
            }
            
            const days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
            let html = `<div style="background: white; padding: 20px; border-radius: 10px; max-width: 400px;">\n<h3>Week ${weekNum} Habit Tracker</h3>\n`;
            
            habits.forEach((habit, hIdx) => {
                if (!habit.emoji) return;
                const weekLogs = habit.weeklyLogs[weekNum] || Array(7).fill(false);
                html += `<div style="margin: 15px 0; padding: 10px; background: #f4e8d0; border-radius: 8px;">
                    <div style="font-size: 1.2em; margin-bottom: 10px;">${habit.emoji} ${habit.name} (${habit.frequency}x/week)</div>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">`;
                
                days.forEach((day, dIdx) => {
                    const checked = weekLogs[dIdx] ? 'checked' : '';
                    html += `<label style="display: flex; align-items: center; gap: 5px;">
                        <input type="checkbox" ${checked} onchange="toggleHabitDay(${weekNum}, ${hIdx}, ${dIdx})">
                        <span>${day}</span>
                    </label>`;
                });
                
                html += `</div></div>`;
            });
            
            html += `<button onclick="closeHabitLogger()" style="margin-top: 10px; padding: 10px 20px; background: #2d6a4f; color: white; border: none; border-radius: 8px; cursor: pointer;">Done</button></div>`;
            
            // Create modal
            const modal = document.createElement('div');
            modal.id = 'habitLoggerModal';
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 10000;';
            modal.innerHTML = html;
            modal.onclick = (e) => { if (e.target === modal) closeHabitLogger(); };
            document.body.appendChild(modal);
        }
        
        function toggleHabitDay(weekNum, habitIdx, dayIdx) {
            if (!habits[habitIdx].weeklyLogs[weekNum]) {
                habits[habitIdx].weeklyLogs[weekNum] = Array(7).fill(false);
            }
            habits[habitIdx].weeklyLogs[weekNum][dayIdx] = !habits[habitIdx].weeklyLogs[weekNum][dayIdx];
            
            // Check if week is complete
            const allComplete = habits.every(habit => {
                if (!habit.emoji) return true;
                const logs = habit.weeklyLogs[weekNum] || Array(7).fill(false);
                return logs.filter(Boolean).length >= habit.frequency;
            });
            
            // FIX: Update potsOfGold array properly
            const potIndex = potsOfGold.indexOf(weekNum);
            if (allComplete && potIndex === -1) {
                // Week just became complete - add it
                potsOfGold.push(weekNum);
                showConfetti();
                updateAnnualTracker();
            } else if (!allComplete && potIndex !== -1) {
                // Week is no longer complete - remove it
                potsOfGold.splice(potIndex, 1);
                updateAnnualTracker();
            }
            
            saveToLocalStorage();
            // Don't refresh modal - just let checkboxes update naturally
            // The dashboard will update when modal closes
        }
        
        function closeHabitLogger() {
            const modal = document.getElementById('habitLoggerModal');
            if (modal) modal.remove();
            renderDashboard(); // Refresh to show updated tracks
        }
        
        function showConfetti() {
            for (let i = 0; i < 100; i++) { // More confetti!
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = Math.random() * 100 + '%';
                confetti.style.animationDelay = Math.random() * 0.5 + 's';
                confetti.style.animationDuration = (3 + Math.random() * 2) + 's'; // 3-5 seconds
                confetti.style.background = ['#FF0000', '#FFA500', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3'][Math.floor(Math.random() * 7)];
                document.body.appendChild(confetti);
                setTimeout(() => confetti.remove(), 5000); // Remove after 5 seconds
            }
        }
        
        function customAlert(message) {
            const modal = document.createElement('div');
            modal.id = 'customAlertModal';
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 10001;';
            modal.innerHTML = `
                <div style="background: white; padding: 30px; border-radius: 15px; max-width: 350px; text-align: center;">
                    <p style="font-size: 1.1em; margin: 0 0 20px 0;">${message}</p>
                    <button id="customAlertOkBtn" style="padding: 12px 40px; background: #2d6a4f; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 1em;">OK</button>
                </div>
            `;
            document.body.appendChild(modal);
            
            // Add click handler after modal is in DOM
            document.getElementById('customAlertOkBtn').onclick = function() {
                modal.remove();
            };
        }
        
        function renderDashboard() {
            const grid = document.getElementById('timelineGrid');
            grid.innerHTML = '';
            
            // Always show habits column - wider for rainbow arch
            grid.style.gridTemplateColumns = `150px 280px repeat(${plans.length}, minmax(250px, 1fr))`;
            
            // Add headers row
            const weekHeader = document.createElement('div');
            weekHeader.className = 'plan-header';
            weekHeader.style.background = '#1a4d2e';
            weekHeader.textContent = 'üìÖ Weeks';
            grid.appendChild(weekHeader);
            
            // Add Habits column header - always show and always clickable
            const habitsHeader = document.createElement('div');
            habitsHeader.className = 'plan-header';
            habitsHeader.style.background = '#2d4a4f';
            habitsHeader.style.cursor = 'pointer';
            if (!habits.some(h => h.emoji)) {
                habitsHeader.innerHTML = 'üåà Habits ‚ûï';
            } else {
                habitsHeader.innerHTML = 'üåà Habits';
            }
            habitsHeader.onclick = setupHabits;
            grid.appendChild(habitsHeader);
            
            plans.forEach((plan, index) => {
                const planHeader = document.createElement('div');
                planHeader.className = 'plan-header';
                planHeader.textContent = plan.name;
                planHeader.onclick = (e) => showPlanContextMenu(e, index);
                grid.appendChild(planHeader);
            });
            
            // Track tasks by week for each plan
            const tasksByWeek = {};
            plans.forEach(plan => {
                tasksByWeek[plan.id] = {};
                plan.tasks.forEach(task => {
                    if (!tasksByWeek[plan.id][task.week]) {
                        tasksByWeek[plan.id][task.week] = [];
                    }
                    tasksByWeek[plan.id][task.week].push(task);
                });
            });
            
            let previousMonth = '';
            weeks.forEach((week, idx) => {
                // Add thin divider before first week of new month
                if (week.month !== previousMonth && idx > 0) {
                    const monthStartDivider = document.createElement('div');
                    monthStartDivider.className = 'full-width-divider';
                    grid.appendChild(monthStartDivider);
                }
                
                // Week label cell
                const weekLabel = document.createElement('div');
                weekLabel.className = 'week-label';
                weekLabel.innerHTML = `<strong>${week.label}</strong><br><small style="color: #666;">${week.dates}</small>`;
                weekLabel.id = `week-${week.number}`;
                grid.appendChild(weekLabel);
                
                // Add Habits Racing Track - always show
                const habitsCell = document.createElement('div');
                habitsCell.className = 'habits-column';
                habitsCell.onclick = () => habits.some(h => h.emoji) ? openHabitLogger(week.number) : setupHabits();
                habitsCell.innerHTML = renderRainbowTracks(week.number);
                grid.appendChild(habitsCell);
                
                // Plan cells for this week
                plans.forEach(plan => {
                    const planCell = document.createElement('div');
                    planCell.style.padding = '10px';
                    planCell.style.background = '#f4e8d0';
                    planCell.style.minHeight = '80px';
                    planCell.style.borderLeft = '1px solid #d4c5a9';
                    planCell.style.borderRight = '1px solid #d4c5a9';
                    planCell.style.boxSizing = 'border-box';
                    
                    // Add tasks for this week
                    const weekTasks = tasksByWeek[plan.id][week.label] || [];
                    weekTasks.forEach((task, taskIdx) => {
                        const taskDiv = createTaskElement(plan.id, task, taskIdx, week);
                        planCell.appendChild(taskDiv);
                    });
                    
                    grid.appendChild(planCell);
                });
                
                // Add divider after every week (thin for regular weeks, bold at month end)
                const divider = document.createElement('div');
                divider.className = `full-width-divider ${week.isMonthEnd ? 'month-end' : ''}`;
                grid.appendChild(divider);
                
                // Add reflection section at month end
                if (week.isMonthEnd && week.month !== previousMonth) {
                    const reflectionDiv = document.createElement('div');
                    reflectionDiv.className = 'month-reflection';
                    reflectionDiv.innerHTML = `
                        <button class="month-reflection-btn" onclick="toggleReflection('${week.month}')">
                            üìù ${getMonthName(week.month)} Reflection
                        </button>
                        <div class="month-reflection-box" id="reflection-${week.month}">
                            <div class="reflection-label">${getMonthName(week.month)} Reflection</div>
                            <textarea 
                                placeholder="How did this month go? What did you accomplish? What challenges did you face? What did you learn?"
                                onchange="saveReflection('${week.month}', this.value)"
                            >${reflections[week.month] || ''}</textarea>
                        </div>
                    `;
                    grid.appendChild(reflectionDiv);
                }
                
                // Update previousMonth after processing each week
                if (week.isMonthEnd) {
                    previousMonth = week.month;
                }
            });
            
            updateModalDropdown();
        }
        
        function getMonthName(abbr) {
            const monthNames = {
                'Jan': 'January', 'Feb': 'February', 'Mar': 'March',
                'Apr': 'April', 'May': 'May', 'Jun': 'June',
                'Jul': 'July', 'Aug': 'August', 'Sep': 'September',
                'Oct': 'October', 'Nov': 'November', 'Dec': 'December'
            };
            return monthNames[abbr] || abbr;
        }
        
        function createTaskElement(planId, task, taskIdx, week) {
            const today = new Date();
            
            // Determine if task is overdue
            let isOverdue = false;
            if (task.status !== 'completed') {
                const endDateStr = week.dates.split(' - ')[1];
                const endDate = new Date(endDateStr + ' 2026');
                if (today > endDate) {
                    isOverdue = true;
                }
            }
            
            let className = 'task-item';
            if (task.status === 'completed') {
                className += ' completed';
            } else if (isOverdue) {
                className += ' overdue';
            }
            
            const taskDiv = document.createElement('div');
            taskDiv.className = className;
            
            let statusEmoji = '‚è≥';
            if (task.status === 'completed') statusEmoji = '‚úÖ';
            else if (isOverdue) statusEmoji = '‚ö†Ô∏è';
            
            // Find the actual task index in the plan
            const plan = plans.find(p => p.id === planId);
            const actualTaskIdx = plan.tasks.findIndex(t => 
                t.week === task.week && t.text === task.text
            );
            
            taskDiv.innerHTML = `
                <div class="task-text">
                    <span class="task-status">${statusEmoji}</span>
                    ${task.text}
                </div>
                <div class="task-actions">
                    <button class="task-action-btn complete" onclick="event.stopPropagation(); toggleTask('${planId}', ${actualTaskIdx})">
                        ${task.status === 'completed' ? '‚Ü©Ô∏è Incomplete' : '‚úì Complete'}
                    </button>
                    <button class="task-action-btn" onclick="event.stopPropagation(); editTask('${planId}', ${actualTaskIdx})">
                        ‚úèÔ∏è Edit
                    </button>
                    <button class="task-action-btn delete" onclick="event.stopPropagation(); deleteTask('${planId}', ${actualTaskIdx})">
                        üóëÔ∏è Delete
                    </button>
                </div>
            `;
            
            // Toggle actions on click
            taskDiv.addEventListener('click', function(e) {
                // Close all other open task actions first
                document.querySelectorAll('.task-item.show-actions').forEach(item => {
                    if (item !== taskDiv) {
                        item.classList.remove('show-actions');
                    }
                });
                // Toggle this task's actions
                taskDiv.classList.toggle('show-actions');
            });
            
            return taskDiv;
        }
        
        
        function openTaskModal(planId) {
            document.getElementById('taskModal').style.display = 'block';
            if (planId) {
                document.getElementById('modalPlan').value = planId;
            }
        }
        
        function toggleReflection(month) {
            const box = document.getElementById(`reflection-${month}`);
            box.classList.toggle('active');
        }
        
        function saveReflection(month, value) {
            reflections[month] = value;
            saveToLocalStorage();
        }
        
        function closeModal() {
            document.getElementById('taskModal').style.display = 'none';
            document.getElementById('modalWeek').value = '';
            document.getElementById('modalTask').value = '';
            document.getElementById('modalStatus').value = 'pending';
        }
        
        function saveTask() {
            const planId = document.getElementById('modalPlan').value;
            const week = document.getElementById('modalWeek').value;
            const text = document.getElementById('modalTask').value;
            const status = document.getElementById('modalStatus').value;
            
            if (!week || !text) {
                customAlert('Please fill in week and task description!');
                return;
            }
            
            saveState();
            const plan = plans.find(p => p.id === planId);
            plan.tasks.push({ week, text, status });
            
            saveToLocalStorage();
            renderDashboard();
            closeModal();
        }
        
        function toggleTask(planId, taskIndex) {
            saveState();
            const plan = plans.find(p => p.id === planId);
            plan.tasks[taskIndex].status = 
                plan.tasks[taskIndex].status === 'completed' ? 'pending' : 'completed';
            
            saveToLocalStorage();
            renderDashboard();
        }
        
        function editTask(planId, taskIndex) {
            const plan = plans.find(p => p.id === planId);
            const task = plan.tasks[taskIndex];
            
            // Edit text
            const newText = prompt('Edit task:', task.text);
            if (!newText || !newText.trim()) return;
            
            // Select new column
            let columnOptions = plans.map((p, i) => `${i + 1}. ${p.name}`).join('\n');
            const currentPlanIdx = plans.findIndex(p => p.id === planId);
            const newColumnStr = prompt(`Move to which column?\n${columnOptions}\n\nCurrent: ${currentPlanIdx + 1}. ${plan.name}\nEnter number (or leave blank to keep):`, '');
            
            let newPlanId = planId;
            if (newColumnStr && newColumnStr.trim()) {
                const colNum = parseInt(newColumnStr) - 1;
                if (colNum >= 0 && colNum < plans.length) {
                    newPlanId = plans[colNum].id;
                }
            }
            
            // Select new week
            const newWeek = prompt('Change week? (1-52, or leave blank to keep):', task.week);
            
            saveState();
            
            // If moving to different column, remove from old and add to new
            if (newPlanId !== planId) {
                plan.tasks.splice(taskIndex, 1);
                const newPlan = plans.find(p => p.id === newPlanId);
                newPlan.tasks.push({
                    text: newText.trim(),
                    week: newWeek && newWeek.trim() ? newWeek.trim() : task.week,
                    status: task.status
                });
            } else {
                // Just update in place
                task.text = newText.trim();
                if (newWeek && newWeek.trim()) {
                    task.week = newWeek.trim();
                }
            }
            
            saveToLocalStorage();
            renderDashboard();
        }
        
        function deleteTask(planId, taskIndex) {
            if (confirm('Are you sure you want to delete this task?')) {
                saveState();
                const plan = plans.find(p => p.id === planId);
                plan.tasks.splice(taskIndex, 1);
                saveToLocalStorage();
                renderDashboard();
            }
        }
        
        window.addNewColumn = function() {
            try {
                alert('Button clicked! About to show prompt...');
                const name = prompt('Enter name for new plan column:', 'Plan G');
                
                alert('You entered: "' + name + '"');
                
                if (!name) {
                    alert('No name entered or cancelled');
                    return;
                }
                
                if (!name.trim()) {
                    alert('Name is empty after trimming');
                    return;
                }
                
                const newId = 'plan' + Date.now();
                const newPlan = { id: newId, name: name.trim(), tasks: [] };
                
                alert('About to add plan: ' + newPlan.name);
                
                plans.push(newPlan);
                
                alert('Plans array now has ' + plans.length + ' items');
                
                saveToLocalStorage();
                
                alert('About to render dashboard...');
                
                renderDashboard();
                
                alert('SUCCESS! Column "' + name + '" added!');
                
            } catch (error) {
                alert('ERROR: ' + error.message);
                console.error('Full error:', error);
            }
        };
        
        function editColumnName(index) {
            const newName = prompt('Enter new name for this column:', plans[index].name);
            if (newName && newName.trim()) {
                plans[index].name = newName.trim();
                saveToLocalStorage();
                renderDashboard();
            }
        }
        
        function showPlanContextMenu(event, planIndex) {
            event.stopPropagation();
            selectedPlanIndex = planIndex;
            
            const menu = document.getElementById('planContextMenu');
            menu.style.left = event.pageX + 'px';
            menu.style.top = event.pageY + 'px';
            menu.classList.add('active');
        }
        
        function hidePlanContextMenu() {
            document.getElementById('planContextMenu').classList.remove('active');
        }
        
        window.renamePlan = function() {
            if (selectedPlanIndex !== null) {
                const newName = prompt('Enter new name for this column:', plans[selectedPlanIndex].name);
                if (newName && newName.trim()) {
                    saveState();
                    plans[selectedPlanIndex].name = newName.trim();
                    saveToLocalStorage();
                    renderDashboard();
                }
                hidePlanContextMenu();
            }
        };
        
        window.movePlanLeft = function() {
            if (selectedPlanIndex !== null && selectedPlanIndex > 0) {
                saveState();
                const temp = plans[selectedPlanIndex];
                plans[selectedPlanIndex] = plans[selectedPlanIndex - 1];
                plans[selectedPlanIndex - 1] = temp;
                saveToLocalStorage();
                renderDashboard();
                hidePlanContextMenu();
            } else {
                customAlert('Cannot move left - already at the start!');
            }
        };
        
        window.movePlanRight = function() {
            if (selectedPlanIndex !== null && selectedPlanIndex < plans.length - 1) {
                saveState();
                const temp = plans[selectedPlanIndex];
                plans[selectedPlanIndex] = plans[selectedPlanIndex + 1];
                plans[selectedPlanIndex + 1] = temp;
                saveToLocalStorage();
                renderDashboard();
                hidePlanContextMenu();
            } else {
                customAlert('Cannot move right - already at the end!');
            }
        };
        
        window.deletePlan = function() {
            if (selectedPlanIndex !== null) {
                const planName = plans[selectedPlanIndex].name;
                const taskCount = plans[selectedPlanIndex].tasks.length;
                
                let confirmMsg = `Delete "${planName}"?`;
                if (taskCount > 0) {
                    confirmMsg += `\n\nThis column has ${taskCount} task(s) that will be deleted.`;
                }
                
                if (confirm(confirmMsg)) {
                    saveState();
                    plans.splice(selectedPlanIndex, 1);
                    saveToLocalStorage();
                    renderDashboard();
                }
                hidePlanContextMenu();
            }
        };
        
        function scrollToCurrentWeek() {
            const today = new Date();
            const currentMonth = today.getMonth();
            const weekOfMonth = Math.ceil(today.getDate() / 7);
            const approximateWeek = (currentMonth * 4) + weekOfMonth;
            
            const weekElement = document.getElementById(`week-${approximateWeek}`);
            if (weekElement) {
                weekElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }
        
        function clearAllData() {
            if (confirm('Are you sure you want to reset the entire dashboard? This cannot be undone!')) {
                localStorage.removeItem('todoListData');
                localStorage.removeItem('todoReflections');
                location.reload();
            }
        }
        
        function updateModalDropdown() {
            const planSelect = document.getElementById('modalPlan');
            planSelect.innerHTML = '';
            plans.forEach(plan => {
                const option = document.createElement('option');
                option.value = plan.id;
                option.textContent = plan.name;
                planSelect.appendChild(option);
            });
            
            const weekSelect = document.getElementById('modalWeek');
            weekSelect.innerHTML = '<option value="">Select a week...</option>';
            weeks.forEach(week => {
                const option = document.createElement('option');
                option.value = week.label;
                option.textContent = `${week.label} (${week.dates})`;
                weekSelect.appendChild(option);
            });
        }
        
        function saveToLocalStorage() {
            localStorage.setItem('todoListData', JSON.stringify(plans));
            localStorage.setItem('todoReflections', JSON.stringify(reflections));
            localStorage.setItem('todoTimers', JSON.stringify(timers));
            localStorage.setItem('todoHabits', JSON.stringify(habits));
            localStorage.setItem('todoPotsOfGold', JSON.stringify(potsOfGold));
            localStorage.setItem('todoTrophyPrize', trophyPrize);
        }
        
        function loadFromLocalStorage() {
            const saved = localStorage.getItem('todoListData');
            if (saved) {
                const loaded = JSON.parse(saved);
                plans.length = 0;
                plans.push(...loaded);
            }
            
            const savedReflections = localStorage.getItem('todoReflections');
            if (savedReflections) {
                Object.assign(reflections, JSON.parse(savedReflections));
            }
            
            const savedTimers = localStorage.getItem('todoTimers');
            if (savedTimers) {
                const loadedTimers = JSON.parse(savedTimers);
                timers.forEach((timer, i) => {
                    if (loadedTimers[i]) {
                        Object.assign(timer, loadedTimers[i]);
                    }
                });
            }
            
            const savedHabits = localStorage.getItem('todoHabits');
            if (savedHabits) {
                habits.length = 0;
                habits.push(...JSON.parse(savedHabits));
            }
            
            const savedPots = localStorage.getItem('todoPotsOfGold');
            if (savedPots) {
                potsOfGold.length = 0;
                potsOfGold.push(...JSON.parse(savedPots));
            }
            
            // FIX: Validate and rebuild potsOfGold based on actual habit completion
            const validatedPots = [];
            for (let weekNum = 1; weekNum <= 52; weekNum++) {
                const allComplete = habits.every(habit => {
                    if (!habit.emoji) return true;
                    const logs = habit.weeklyLogs[weekNum] || Array(7).fill(false);
                    return logs.filter(Boolean).length >= habit.frequency;
                });
                if (allComplete) {
                    validatedPots.push(weekNum);
                }
            }
            potsOfGold = validatedPots;
            console.log('Validated potsOfGold:', potsOfGold);
            
            const savedPrize = localStorage.getItem('todoTrophyPrize');
            if (savedPrize) {
                trophyPrize = savedPrize;
                const prizeInput = document.getElementById('trophyPrize');
                if (prizeInput) prizeInput.value = trophyPrize;
            }
        }
        
        // Initialize
        loadFromLocalStorage();
        renderDashboard();
        updateTimers();
        updateAnnualTracker();
        
        // Register service worker for PWA
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('data:text/javascript;base64,c2VsZi5hZGRFdmVudExpc3RlbmVyKCdpbnN0YWxsJywgZnVuY3Rpb24oZSkge2Uud2FpdFVudGlsKHNlbGYuc2tpcFdhaXRpbmcoKSl9KTtzZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ2FjdGl2YXRlJyxmdW5jdGlvbihlKXtyZXR1cm4gc2VsZi5jbGllbnRzLmNsYWltKCl9KTs=').catch(err => console.log('SW registration failed'));
        }
        
        // Add event listeners to buttons
        document.getElementById('jumpToWeekBtn').addEventListener('click', function() {
            scrollToCurrentWeek();
        });
        
        document.getElementById('undoBtn').addEventListener('click', function() {
            undo();
        });
        
        document.getElementById('redoBtn').addEventListener('click', function() {
            redo();
        });
        
        document.getElementById('zoomOutBtn').addEventListener('click', function() {
            const grid = document.getElementById('timelineGrid');
            const container = document.querySelector('.timeline-container');
            const gridWidth = grid.scrollWidth;
            const containerWidth = container.clientWidth;
            const scale = (containerWidth / gridWidth) * 0.95;
            
            grid.style.transform = `scale(${scale})`;
            grid.style.transformOrigin = 'top left';
            container.style.overflow = 'hidden';
        });
        
        document.getElementById('zoomInBtn').addEventListener('click', function() {
            const grid = document.getElementById('timelineGrid');
            const container = document.querySelector('.timeline-container');
            
            grid.style.transform = 'scale(1)';
            grid.style.transformOrigin = 'top left';
            container.style.overflow = 'auto';
        });
        
        document.getElementById('addColBtn').addEventListener('click', function() {
            const colName = prompt('Enter name for new column:', 'Plan K');
            if (colName && colName.trim()) {
                saveState(); // Save before changing
                const newId = 'plan' + Date.now();
                plans.push({ id: newId, name: colName.trim(), tasks: [] });
                saveToLocalStorage();
                renderDashboard();
            }
        });
        
        document.getElementById('floatingAddBtn').addEventListener('click', function() {
            openTaskModal();
        });
        
        // Hide context menu when clicking anywhere else
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.plan-context-menu') && !e.target.closest('.plan-header')) {
                hidePlanContextMenu();
            }
        });
        
        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('taskModal');
            if (event.target === modal) {
                closeModal();
            }
        }
    </script>
</body>
</html>